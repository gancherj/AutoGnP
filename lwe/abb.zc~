
operator Chi : BS_chir -> Matrix_{m+1,1}.

adversary Adv_LWE : (Matrix_{n,m+1} * Matrix_{m+1,1}) -> Bool.
assumption LWE
[ A <-$ Matrix_{n,m+1}; s <-$ Matrix_{n,1}; chir <-$ BS_chir; b <- Adv_LWE (A, (tr A) * s + Chi(chir));]
[ A <-$ Matrix_{n,m+1}; u <-$ Matrix_{m+1,1}; b <- Adv_LWE(A,u);].

operator Rinj : BS_rinjr -> Matrix_{m,m}. (* Rr has the denotation m^2 *)
adversary Adv_LHL : (Matrix_{n,m} * Matrix_{n,m} * Matrix_{m,1}) -> Bool.

assumption LHL
[ A <-$ Matrix_{n,m}; rinjr <-$ BS_rinjr; let R = Rinj(rinjr); w <-$ Matrix_{m,1}; b <- Adv_LHL(A,A*R,(tr R) * w);]
[ A <-$ Matrix_{n,m}; rinjr <-$ BS_rinjr; let R = Rinj(rinjr); B <-$ Matrix_{n,m}; w <-$ Matrix_{m,1}; b <- Adv_LHL(A,B,(tr R) * w);].


operator TrapGen : BS_tgr -> (Matrix_{n,m} * Matrix_{m,m}).
operator SampleLeft : (BS_slr * Matrix_{n,m} * Matrix_{n,m} * Matrix_{m,m} * Matrix_{n,1}) -> Matrix_{m+m,1}.
operator SampleRight : 
(BS_srr * Matrix_{n,m} * Matrix_{n,m} * Matrix_{m,m} * Matrix_{m,m} * Matrix_{n,1}) -> Matrix_{m+m,1}.
operator IdHash : BS_n -> Matrix_{n,n}. (* domain of this could change *)




  (* A1 : () to id space *)
adversary Adv1 : () -> BS_n.

operator Minj : Bool -> Matrix_{1,1}.

oracle KeyGen : BS_n -> Matrix_{m+m, 1}.

  (* A3 : challenge ciphertext to bool *)

adversary Adv2 : (Matrix_{n,m} * Matrix_{n,m} * Matrix_{n,m} * Matrix_{n,1} * (* public parameters *)
               Matrix_{m+m,1} * Matrix_{1,1}) (* ciphertext *) -> Bool.
bound_adv [
  i' <- Adv1();

  (* public parameter *)
  tgr <-$ BS_tgr;
  let A = TrapGen(tgr)#0;
  let TA = TrapGen(tgr)#1;
    A1 <-$ Matrix_{n,m};
    B <-$ Matrix_{n,m};
    u <-$ Matrix_{n,1};

  (* challenge encryption *)
    b <-$ Bool;
  let Hid' = IdHash(i');
    s <-$ Matrix_{n,1};
    Rr <-$ BS_rinjr; let R = Rinj(Rr);
    chir <-$ BS_chir; let e0 = tr sl tr Chi(chir); let e1 = tr sr tr Chi(chir);
  let c0 = (tr s) * (A || Hid' * B) + (tr e0 || (tr e0) * R);
  let c1 = (tr s) * u + e1 + Minj(b);
  
    b' <- Adv2 (A, A1, B, u, tr c0, c1) with
  KeyGen(id) = {
    guard (id <> i');
    slr <-$ BS_slr;
    return SampleLeft(slr, A, A1 + IdHash(id) * B, TA, u)
    };
  
  (*  b' <- A3(challenge ciphertext of b) with KG oracle *)
  ] : b = b'.
  norm.
  move 8 3.
  abstract (10,1,3) a A1.
 
  
  trans*
  [
    subst  (A1 -> TrapGen(tgr)#0 * Rinj(Rr) + IdHash(i') * B)
  ].



  