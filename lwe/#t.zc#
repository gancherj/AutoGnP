
operator Chi : BS_r -> Matrix_{m+1,1}.
adversary A_lwe : (Matrix_{n,m+1} * Matrix_{m+1,1}) -> Bool.
assumption LWE
 [ A <-$ Matrix_{n,m+1}; s <-$ Matrix_{n,1}; r <-$ BS_r; b <- A_lwe(A, (tr A) * s + Chi(r));]
 [ A <-$ Matrix_{n,m+1}; u <-$ Matrix_{m+1,1}; b <- A_lwe(A, u);].

 operator bit_inj : BS_m -> Matrix_{m,1}.
 adversary A_lhl : (Matrix_{n,m} * Matrix_{n,1}) -> Bool.
 assumption LHL
 [ A <-$ Matrix_{n,m}; e <-$ BS_m; b <- A_lhl(A, A * bit_inj(e));]
 [ A <-$ Matrix_{n,m}; u <-$ Matrix_{n,1}; b <- A_lhl(A, u);].

adversary A_pke : (Matrix_{n,m} * Matrix_{m,1} * Matrix_{n,1} * Matrix_{1,1}) -> Bool.

operator Mu : () -> Matrix_{1,1}.

adversary A_ : Matrix_{1,1} -> Bool.  

bound_adv [
  b <-$ Bool;
  let m = b?Mu(()):0_{1,1};
    r <-$ Matrix_{1,1};
    b' <- A_(r + m);
  v__ <-$ Matrix_{1,1};
  let xx = ((b?Mu(()):0_{1,1})+r) - (b?Mu(()):0_{1,1});
] : b = b'.
enable_debug.

rnd! r (x -> x - (b?Mu(()):0_{1,1})) (x -> x + (b?Mu(()):0_{1,1})).

norm.
move 1 3.
indep!.
rnd! r (x -> x - (b?Mu(()):0)) (x -> x + (b?Mu(()):0)).

norm.
move 1 3.
indep!.    



bound_adv [
  let mu = Mu(());
    b <-$ Bool; let m = 0_{1,1};
    re <-$ BS_m;
  let e = bit_inj(re);
  
   A <-$ Matrix_{n,m};
  let u = A * e;
    s <-$ Matrix_{n,1};
  
     r <-$ BS_r;
   let X_ = tr Chi(r);
   let X = tr (sl X_);
   let x = tr (sr X_);

   let c1 = (tr A) * s + X;
   let c2 = (tr u) * s + x + m;
   b' <- A_pke (A,c1,u,c2);
 ] : b=b'.
move A 1.

norm.
assumption_decisional! LHL -> t.