(* structural operators *)
operator ListOf : Matrix_{n,m} -> List_{d} Matrix_{n,m}.
operator ListOfm : Matrix_{1,m} -> List_{d} Matrix_{1,m}.
operator ListOfn : Matrix_{1,n} -> List_{d} Matrix_{1,n}.

(* ListTail(A, ids) returns the tail of A after the IDs are bot. *)
operator ListTail : (List_{d} Matrix_{n,m} * List_{d} BS_id) -> List_{d} Matrix_{n,m}.

adversary intro_adv : () -> Bool.
assumption introduce_ai [Ai <-$ List_{d} Matrix_{n,m}; b <- intro_adv(); ] [b <- intro_adv();].

operator Chi0 : BS_chi -> Matrix_{m,1}.
operator Chi1 : BS_chi -> Matrix_{1,1}.
adversary Adv_LWE : (Matrix_{n,m+1} * Matrix_{m+1,1}) -> Bool.
assumption LWE
[ A <-$ Matrix_{n,m+1}; s <-$ Matrix_{n,1}; chir0 <-$ BS_chi; chir1 <-$ BS_chi; b <- Adv_LWE (A, (tr A) * s + tr (tr Chi0(chir0) || tr Chi1(chir1)));]
[ A <-$ Matrix_{n,m+1}; u <-$ Matrix_{m+1,1}; b <- Adv_LWE(A,u);].



operator TrapGen : BS_tgr -> (Matrix_{n,m} * Matrix_{m,m}).

operator Rinj : BS_rinjr -> List_{d} Matrix_{m,m}.
adversary Adv_LLHL : (BS_tgr * Matrix_{n,m} * List_{d} Matrix_{n,m} * List_{d} Matrix_{1,m}) -> Bool.
adversary Adv_LLHLchoose : () -> List_{d} Matrix_{1,m}.
assumption LLHL
[ tgr <-$ BS_tgr; rinjr <-$ BS_rinjr; w <- Adv_LLHLchoose();
  b <- Adv_LLHL(tgr , TrapGen(tgr)#0 , ListOf(TrapGen(tgr)#0) * Rinj(rinjr),
    w * Rinj(rinjr));]
[ tgr <-$ BS_tgr;  rinjr <-$ BS_rinjr; Ai <-$ List_{d} Matrix_{n,m}; w <- Adv_LLHLchoose(); b <- Adv_LLHL(tgr , TrapGen(tgr)#0, Ai , w * Rinj(rinjr));].


type sktype.
(*todo what is t*)
operator ListSampleLeft : (BS_sl * (Matrix_{n,m} * List_{d} Matrix_{n,m}) * List_{d} Matrix_{n,m} * sktype) -> sktype. 
operator ListIdHash : List_{d} BS_id -> List_{d} Matrix_{n,n}.

(* IsPrefix(a,b) returns true when a is a prefix of b or vice versa *)
operator IsPrefix : (List_{d} BS_id * List_{d} BS_id) -> Bool.
(* IsValidSK(F, skF) returns true when skF is a valid trapdoor for F *)
operator IsValidSK : ((Matrix_{n,m} * List_{d} Matrix_{n,m}) * sktype) -> Bool.
oracle Derive : (List_{d} BS_id * List_{d} BS_id * sktype) -> sktype.
operator Minj : Bool -> Matrix_{1,1}.
adversary Adv1 : () -> List_{d} BS_id.



adversary Adv2 : (Matrix_{n,m} * List_{d} Matrix_{n,m} * Matrix_{n,m} * Matrix_{n,1} * (Matrix_{1,m} * List_{d} Matrix_{1,m}) * Matrix_{1,1}) -> Bool.

bound_adv [
  id' <- Adv1();
  
  tgr <-$ BS_tgr;
  let A = TrapGen(tgr)#0;
  let TA = TrapGen(tgr)#1;
  Ai <-$ List_{d} Matrix_{n,m};
  B <-$ Matrix_{n,m};
  u <-$ Matrix_{n,1};

    (*challene encryption*)
    b <-$ Bool;
  let Hid' = ListIdHash(id');
    s <-$ Matrix_{n,1};
  rinjr <-$ BS_rinjr; let R = Rinj(rinjr);
    chir0 <-$ BS_chi; let e0 = Chi0(chir0);
    chir1 <-$ BS_chi; let e1 = Chi1(chir1);
  let F = (A, Ai + Hid' * ListOf(B));
  let c0 = ((tr s) * F#0 + (tr e0), ListOfn(tr s) * F#1 + ListOfm(tr e0) * R);
  let c1 = (tr s) * u + e1 + Minj(b);
    b' <- Adv2 (A, Ai, B, u, c0, c1) with
  Derive (tt) = {
    let idold = tt#0;
    let idnew = tt#1;
    let skidold = tt#2;
    guard (IsPrefix(idold, id') <> true);
    guard (IsPrefix(idnew, id') <> true);
    guard (IsValidSK((A, Ai + ListIdHash(idold) * ListOf(B)), skidold) = true);
    slr <-$ BS_sl;
    return ListSampleLeft(slr,(A, Ai + ListIdHash(idold) * ListOf(B)), ListTail(Ai + ListIdHash(idnew) * ListOf(B), idold), skidold);
    };
  
  
  ] : b = b'.
  move 5 6.
  abstract 7 A1t Ai.
  move 12 2.
  rnd Ai (X -> X - ListIdHash(id') * ListOf(B)) (X -> X + ListIdHash(id') * ListOf(B)); unfold u__.
  trans* [subst 7 (Ai -> ListOf(A) * Rinj(rinjr))].
  norm.
  move tgr 1.
  move rinjr 2.
  move Ai 3.
  abstract 4 tta ().
  move chir0 5.
  abstract 6 resa (ListOfm (tr Chi0(chir0))).
  abstract 7 tta2 (tgr, TrapGen(tgr)#0, Ai, resa * Rinj(rinjr)).
  abstract 15 res2 (b = b').
  assumption_decisional LLHL <- [tta resa] [tta2 res2] .
  LR: norm.
  assumption_decisional! introduce_ai <- Ai .
  LR: norm.
  move id' 1.
  move rinjr 2.
  move tgr 3.
  move B 4.
  move Ai 5.
  move u 6.
  move b 7.
  move s 8.
  move chir0 9.
  move chir1 10.
  dist_eq.
  