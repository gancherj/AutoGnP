operator Chi : BS_r -> Matrix_{m+1,1}.
adversary A_lwe : (Matrix_{n,m} * Matrix_{n,1} * Matrix_{m,1} * Matrix_{1,1}) -> Bool.
assumption LWEsp
[ A <-$ Matrix_{n,m+1}; s <-$ Matrix_{n,1}; r <-$ BS_r;
  let arg1 = A;
  let arg2 = (tr A) * s + Chi(r);
    b <- A_lwe(sl A, sr A, tr sl tr arg2, tr sr tr arg2);]
 [ A <-$ Matrix_{n,m+1}; u <-$ Matrix_{m+1,1}; b <- A_lwe(sl A, sr A, tr sl tr u, tr sr tr u);].

 operator bit_inj : BS_m -> Matrix_{m,1}.
 adversary A_lhl : (Matrix_{n,m} * Matrix_{n,1}) -> Bool.
 assumption LHL
 [ A <-$ Matrix_{n,m}; e <-$ BS_m; b <- A_lhl(A, A * bit_inj(e));]
 [ A <-$ Matrix_{n,m}; u <-$ Matrix_{n,1}; b <- A_lhl(A, u);].

adversary A_pke : (Matrix_{n,m} * Matrix_{m,1} * Matrix_{n,1} * Matrix_{1,1}) -> Bool.

operator Mu : () -> Matrix_{1,1}.

bound_adv [
  let mu = Mu(());
    b <-$ Bool; let m = b?mu:0_{1,1};
    re <-$ BS_m;
  let e = bit_inj(re);
  
   A <-$ Matrix_{n,m};
  let u = A * e;
    s <-$ Matrix_{n,1};
  
     r <-$ BS_r;
   let X_ = tr Chi(r);
   let X = tr (sl X_);
   let x = tr (sr X_);

   let c1 = (tr A) * s + X;
   let c2 = (tr u) * s + x + m;
   b' <- A_pke (A,c1,u,c2);
 ] : b=b'.
 

move A 1.
move 3 2.
assumption_decisional! LHL -> u.
trans*
[
  insert 1 [Au <-$ Matrix_{n,m+1};],
  subst 2 (A -> sl Au),
  subst 2 (u -> sr Au)
].
    admit.
move 7 2.
move 7 2.
assumption_decisional! LWEsp -> t1.